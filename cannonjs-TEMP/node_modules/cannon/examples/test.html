<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			body { 
                overflow: hidden;
                margin: 0; }
		</style>
	</head>
	<body>
        <canvas id="canvas">
            
        </canvas>

        <script src="../../three/build/three.js"></script>

        <script src="../../three/examples/js/loaders/GLTFLoader.js"></script>

        <script src="../build/cannon.js"></script>
        <script src="../tools/threejs/CannonDebugRenderer.js"></script>
        <script src="../libs/TrackballControls.js"></script>
        <script src="FontLoader.js"></script>
        <script src="TextGeometry.js"></script>

      

		<script>

            var GHaut,GMillieu,GBas,DHaut,DMillieu,DBas;
            var meteorMesh;
            var GHBody,GMBody,GBBody,DHBody,DMBody,DBBody,portfolioBody;
            var scene,camera,renderer,light;
            var portfolio;
            var light; 
            var parchemin;
            var AD_GLPI,OCS_Inventory,Mantis_BT,LAMP,Wordpress_Nginx,Hugo,Env_Developpement,Autre,encore_un_autre_truc;
            var txt_AD_GLPI,txt_OCS_Inventory,txt_Mantis_BT,txt_LAMP,txt_Wordpress_Nginx,txt_Hugo,txt_Env_Developpement,txt_Autre,txt_encore_un_autre_truc;

            var tab = [];
            
                var meshNames = [{name:"GHaut", x:-11,y:4,z:0},
                {name:"GMillieu", x:"",y:"",z:""},
                {name:"GBas", x:"",y:"",z:""},
                {name:"DHaut", x:"",y:"",z:""},
                {name:"DMillieu", x:"",y:"",z:""},
                {name:"DBas", x:"",y:"",z:""}];
                
                var tabParchemins = [];

                var meshParchemins = [
                    {name:"AD_GLPI", x:-14,y:-57,z:2,nt:"txt_AD_GLPI",t:"GLPI & Active Directory"},
                    {name:"OCS_Inventory", x:-14,y:-61,z:2,nt:"txt_OCS_Inventory",t:"OCS Inventory"},
                    {name:"Mantis_BT", x:-14,y:-65,z:2,nt:"txt_Mantis_BT",t:"Mantis BT"},
                    {name:"LAMP", x:-2,y:-57,z:2,nt:"txt_LAMP",t:"LAMP"},
                    {name:"Env_Developpement",x:10,y:-61,z:2,nt:"txt_Env_Developpement",t:"Gitlab"},
                    {name:"Hugo", x:-2,y:-61,z:2,nt:"txt_Hugo",t:"Hugo"},
                    {name:"Wordpress_Nginx", x:-2,y:-65,z:2,nt:"txt_Wordpress_Nginx",t:"Wordpress & Nginx"},
                    {name:"Autre", x:10,y:-65,z:2,nt:"txt_Autre",t:"A venir"},
                    {name:"Encore_Autre", x:10,y:-57,z:2,nt:"txt_encore_un_autre_truc",t:"A venir"}
                    
                ];

                // GLPI OCS WORDPRESS/NGINX MANTIS BT HUGO LAMP VM AD/GLPI IIS ENVDEVELOPPEMENT
            var world;
              
            // initialise three js
            initThree();

            // initialise cannon js 
            initCannon()

            // charge les models three js
            initModels();
            // charge les models de physique / hitbox cannon js
            initBody();


           LoadTxt();

          
          
                //on build le metor la osef de blender
            const geometry = new THREE.BoxGeometry( 0.2, 0.2, 0.2 );
            const geometryy = new THREE.BoxGeometry( 0.5, 0.5, 0.5 );
            const texture = new THREE.TextureLoader().load( "lavee.jpg" );
            const lava = new THREE.MeshBasicMaterial( {color:0xffa500} );
         

            

            var unMeteor = new THREE.Mesh( geometryy, lava );
            var deuxMeteor = new THREE.Mesh( geometry, lava );

            var troisMeteor = new THREE.Mesh( geometry, lava );

            var quatreMeteor = new THREE.Mesh( geometry, lava );

            var cinqMeteor = new THREE.Mesh( geometry, lava );

            const meteors = new THREE.Group();



            meteors.add(unMeteor,deuxMeteor,troisMeteor,quatreMeteor,cinqMeteor);
            scene.add( meteors );


			const timeStep = 1 / 60;



            var stars = Array();

            function starsBackground(){
                const geometry = new THREE.BoxGeometry( 0.5, 0.5, 0.5 );
                const material = new THREE.MeshBasicMaterial( {color: 0xffffff} );
                
                

                for (let i = 0; i < 3000; i++) {
                    stars[i] = new THREE.Mesh( geometry, material );
                    stars[i].position.z = getRandomArbitrary(-150,-50)
                    stars[i].position.y = getRandomArbitrary(-170,80) //-80 // 80
                    stars[i].position.x = getRandomArbitrary(-170,170) //-170 // 80
                    scene.add( stars[i] );
                }
                

              
            }

            starsBackground();
            planesBackground()

            var t = 0;
            function  updateStars() {

                stars[Math.round(getRandomArbitrary(0,1999))].position.x += 1
                stars[Math.round(getRandomArbitrary(0,1999))].position.x -= 1
                
                // console.log(Math.round(getRandomArbitrary(0,2000)));
                
            }












			function animate() {
                requestAnimationFrame( animate );
                world.step(timeStep)
                
                // met a jour les positions three js copie cannon js
                updateQuaternion();
                // cannonDebugRenderer.update();

                // controls.update();
                
                updateStars();
           
                // camera.position.y = -60
               if(tabParchemins["Autre"]){

                meshParchemins.forEach((meshParchemins) =>{

                    tabParchemins[meshParchemins.name].rotation.y +=0.01
          
                })

              }

                mainMeteorBody.quaternion.y += 0.5
                renderer.render( scene, camera );

                if (mainMeteorBody.position.x < -100) {
                    console.log("trop loin");
                    mainMeteorBody.position.set(getRandomArbitrary(40,50),getRandomArbitrary(40,50),getRandomArbitrary(0,3))
                    mainMeteorBody.velocity.setZero();
                }
				
                
			};
            
            animate();












            // fonction qui permet de charger le text
            function LoadTxt() {
                var textloader = new THREE.FontLoader();
                textloader.load('fontMc.json', function(font) {


                // Load le materiel commun

                var material = new THREE.MeshBasicMaterial({
                    color: 0xffffff
                });


                //géometrie du titre portfolio

                var geoPortfolio = new THREE.TextGeometry('Portfolio', {
                    font: font,
                    size: 1,
                    height: 0.1,  
                    
                });

                geoPortfolio.center();

                // géométrie du text contact
                var geoContact = new THREE.TextGeometry('Contact', {
                    font: font,
                    size: 0.7,
                    height: 0.05,  
                });

                geoContact.center();

                //géométrie du profil
                var geoProfile = new THREE.TextGeometry('Profil', {
                    font: font,
                    size: 0.7,
                    height: 0.05,  
                });

                geoProfile.center();


                // géométrie du text parcours 
                var geoParcours = new THREE.TextGeometry('Parcours', {
                    font: font,
                    size: 0.7,
                    height: 0.05,  
                });

                geoParcours.center();
                
                // géométrie du text documentations 
                var geoDocumentations = new THREE.TextGeometry('Documentations', {
                    font: font,
                    size: 0.7,
                    height: 0.05,  
                });

                geoDocumentations.center();

                // géométrie du text compétences 
                var geoCompetences = new THREE.TextGeometry('Competences', {
                    font: font,
                    size: 0.7,
                    height: 0.05,  
                });

                geoCompetences.center();

                // géométrie du text certifications 
                var geoCertifications = new THREE.TextGeometry('Certifications', {
                    font: font,
                    size: 0.7,
                    height: 0.05,
                });

                geoCertifications.center();



                
                certifications = new THREE.Mesh(geoCertifications, material);
                scene.add(certifications);
                certifications.position.set(8.7,-4,0.159999999999999973);
                certifications.rotation.y = -0.12029794870860182;

                competences = new THREE.Mesh(geoCompetences, material);
                scene.add(competences);
                competences.position.set(9.25,0,0.14999999999999997);
                competences.rotation.y = -0.12029794870860182;


                documentations = new THREE.Mesh(geoDocumentations, material);
                scene.add(documentations);
                documentations.position.set(-8.4,-4,1.39);
                documentations.rotation.y =0.09700000000000006;


                parcours = new THREE.Mesh(geoParcours, material);
                scene.add(parcours);
                parcours.rotation.y =0.09700000000000006;

                parcours.position.set(-9.2,0,1.3499999999999999);


                profil = new THREE.Mesh(geoProfile, material);
                scene.add(profil);
                profil.position.set(-9.7,4,1.39);
                profil.rotation.y =0.09700000000000006;


                contact = new THREE.Mesh(geoContact, material);
                scene.add(contact);
                contact.position.set(9.7,4,0.2);
                contact.rotation.y = -0.14299999999999993;


                


                portfolio = new THREE.Mesh(geoPortfolio, material);
                scene.add(portfolio);

                // Titles
                
                TitleProfil = new THREE.Mesh(geoProfile, material);
                scene.add(TitleProfil);
                TitleProfil.position.y = -11.5

                TitleParcours = new THREE.Mesh(geoParcours, material);
                scene.add(TitleParcours);
                TitleParcours.position.y = -31.5

                TitleDocumentation = new THREE.Mesh(geoDocumentations, material);
                scene.add(TitleDocumentation);
                TitleDocumentation.position.y = -51.5

                geoCertifications = new THREE.Mesh(geoCertifications, material);
                scene.add(geoCertifications);
                geoCertifications.position.y = -71.5

                TitleCompetences = new THREE.Mesh(geoCompetences, material);
                scene.add(TitleCompetences);
                TitleCompetences.position.y = -91.5

                TitlegeoContact = new THREE.Mesh(geoContact, material);
                scene.add(TitlegeoContact);
                TitlegeoContact.position.y = -111.5
               
            });  
            
            }

            // input pour bouger le mesh choisi
            document.onkeydown = function (e){
                if (e.keyCode === 37) {
                    // flèche gauche
                    mainMeteorBody.position.z -=0.2
                }else if (e.keyCode === 39) {
                    // flèche droite
                    mainMeteorBody.rotation.y -=0.2
                }else if (e.keyCode === 38) {
                    // vers le fond     
                    mainMeteorBody.position.y +=0.2
                }else if (e.keyCode === 40) {
                    // vers l'avant
                    mainMeteorBody.position.y -=0.2
             
                }else if (e.keyCode === 83) {
                    mainMeteorBody.position.z +=0.2
             
                }else if (e.keyCode === 87) {
                    mainMeteorBody.position.z -=0.2
             
                }
             
             
             }

            // listener qui affiche la collision d'un bodyphysique
            mainMeteorBody.addEventListener("collide",function(e,a){

                var velo = mainMeteorBody.velocity

                
                const x = mainMeteorBody.position.x
                const y = mainMeteorBody.position.y
                const z = mainMeteorBody.position.z

                const vx = mainMeteorBody.velocity.x
                const vy = mainMeteorBody.velocity.y
                const vz = mainMeteorBody.velocity.z

                mainMeteorBody.position.set(getRandomArbitrary(40,50),getRandomArbitrary(40,50),getRandomArbitrary(0,3))
                mainMeteorBody.velocity.setZero();


                deuxexplodedMeteorBody.velocity.set(vx,-vy,vz)

                deuxexplodedMeteorBody.position.set(x+0.1,y+0.1,z+0.1)

                troisexplodedMeteorBody.velocity.set(vx,vy,vz)

                troisexplodedMeteorBody.position.set(x-0.1,y-0.1,z-0.1)


                quatreexplodedMeteorBody.velocity.set(vx,vy,vz)
 
                quatreexplodedMeteorBody.position.set(x+0.2,y+0.2,z+0.2)


                cinqexplodedMeteorBody.velocity.set(vx,vy,vz)

                cinqexplodedMeteorBody.position.set(x-0.2,y-0.2,z-0.2)

                
                // MeteorBody.position.set(mainMeteorBody.position.x+0.1,mainMeteorBody.position.y+0,mainMeteorBody.position.z+0.1)

            })

            // listener qui redimensionne l'écran quand la taille du webview varie
			window.addEventListener( 'resize', onWindowResize, false );

            // fonction qui permet redimensionne la scène par rapport a la taille du webview
            function onWindowResize(){

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            window.addEventListener("wheel", function(e) {

            if (e.deltaY == 100)
            {
                camera.position.y -= 1

            }else
            {
                camera.position.y += 1
            }
            
            }, true);
            
            // fonction qui permet l'initialisation de Three js
            function initThree() {

                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
                renderer = new THREE.WebGLRenderer({ antialias: true, canvas: document.getElementById("canvas") });
                renderer.setPixelRatio(window.devicePixelRatio)
               

                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );

                camera.position.set(0, 0, 13)
                // controls = new THREE.TrackballControls( camera, renderer.domElement );
                
                light = new THREE.AmbientLight( 0xffffff ); // soft white light
                scene.add( light );

                 light = new THREE.AmbientLight( 0x404040 ); // soft white light
                 light.intensity = 2
                scene.add( light );

            }
			
            // fonction qui permet l'initialisation de Cannon js
            function initCannon() {

                // instancie le monde physique
                world = new CANNON.World();

                // gravité sur l'axe des Y a la valeur des Newton / IRL
                world.gravity.set(-1.81,-1.81,0);

                // instancie un debugger pour les shape / hitbox
                cannonDebugRenderer = new THREE.CannonDebugRenderer(scene, world);

            }

            

            function planesBackground() {

                const geometry = new THREE.PlaneGeometry(40, 20);

                const materialProfil = new THREE.MeshBasicMaterial( {color: 0x484848, side: THREE.DoubleSide, opacity:0.5, transparent: true, depthWrite: false} );
                const materialParcours = new THREE.MeshBasicMaterial( {color: 0x505050, side: THREE.DoubleSide, opacity:0.5, transparent: true, depthWrite: false} );
                const materialDocumentations = new THREE.MeshBasicMaterial( {color: 0x797979, side: THREE.DoubleSide, opacity:0.5, transparent: true, depthWrite: false} );
                const materialCertifications = new THREE.MeshBasicMaterial( {color: 0xE8E8E8, side: THREE.DoubleSide, opacity:0.5, transparent: true, depthWrite: false} );
                const materialCompetences = new THREE.MeshBasicMaterial( {color: 0xC2C2C2, side: THREE.DoubleSide, opacity:0.5, transparent: true, depthWrite: false} );
                const materialContact = new THREE.MeshBasicMaterial( {color: 0x9E9E9E, side: THREE.DoubleSide, opacity:0.5, transparent: true, depthWrite: false} );

                const planeProfil = new THREE.Mesh( geometry, materialProfil );
                scene.add( planeProfil );
                planeProfil.position.y = -20
      

                const planeParcours = new THREE.Mesh( geometry, materialParcours );
                scene.add( planeParcours );
                planeParcours.position.y = -40

                const planeDocumentations = new THREE.Mesh( geometry, materialDocumentations );
                scene.add( planeDocumentations );
                planeDocumentations.position.y = -60

                const planeCertifications = new THREE.Mesh( geometry, materialCertifications );
                scene.add( planeCertifications );
                planeCertifications.position.y = -80

                const planeCompetences = new THREE.Mesh( geometry, materialCompetences );
                scene.add( planeCompetences );
                planeCompetences.position.y = -100

                const planeContact = new THREE.Mesh( geometry, materialContact );
                scene.add( planeContact );
                planeContact.position.y = -120

            }

            // fonction qui permet aux models three js de copier la position / quaternions des body physique / cannon
            function updateQuaternion(){
                // // le Sol
                // if(groundMesh){
                //     groundMesh.position.copy(groundBody.position)
                //     groundMesh.quaternion.copy(groundBody.quaternion)
                // }

                
                if(GHaut){
                    // le model glb
                    GHaut.position.copy(GHBody.position)
                    GHaut.quaternion.copy(GHBody.quaternion)
                    
                }


                if (DHaut) {
                    DHaut.position.copy(DHBody.position)
                    DHaut.quaternion.copy(DHBody.quaternion)
                }

                if (GMillieu) {
                    GMillieu.position.copy(GMBody.position)
                    GMillieu.quaternion.copy(GMBody.quaternion)
                }

                if (DMillieu) {
                    DMillieu.position.copy(DMBody.position)
                    DMillieu.quaternion.copy(DMBody.quaternion)
                }

                if (GBas) {
                    GBas.position.copy(GBBody.position)
                    GBas.quaternion.copy(GBBody.quaternion)
                }

                if (DBas) {
                    DBas.position.copy(DBBody.position)
                    DBas.quaternion.copy(DBBody.quaternion)
                }

               

                if (portfolio) {
                    portfolio.position.copy(portfolioBody.position)
                    portfolio.quaternion.copy(portfolioBody.quaternion)
                }

                if (unMeteor) {
                    unMeteor.position.copy(mainMeteorBody.position)
                    unMeteor.quaternion.copy(mainMeteorBody.quaternion)
                }

                if (deuxMeteor) {
                    


                    deuxMeteor.position.copy(deuxexplodedMeteorBody.position)
                    deuxMeteor.quaternion.copy(deuxexplodedMeteorBody.quaternion)

                    troisMeteor.position.copy(troisexplodedMeteorBody.position)
                    troisMeteor.quaternion.copy(troisexplodedMeteorBody.quaternion)

                    quatreMeteor.position.copy(quatreexplodedMeteorBody.position)
                    quatreMeteor.quaternion.copy(quatreexplodedMeteorBody.quaternion)

                    cinqMeteor.position.copy(cinqexplodedMeteorBody.position)
                    cinqMeteor.quaternion.copy(cinqexplodedMeteorBody.quaternion)

                }
              
            }

            // fonction qui permet de charger les models 3d necessaire
            function initModels(){


                // initialisation du loader GLTF
                loader = new THREE.GLTFLoader()

                

                

                // on load le model 3d "testt.glb" (blender)
                loader.load( 'blanc.glb', function ( gltf ) {
                  
                    // tab[0] = { ...tab[0], ...{obj: gltf.scene}};
                    var original = gltf.scene;
                    
                    meshNames.forEach((meshName) =>{
                        console.log(tab[meshName.name])
                        tab[meshName.name] = original.clone();
                        tab[meshName.name].position.set()
                        tab[meshName.name].castShadow = true
                        tab[meshName.name].receiveShadow = true
                        tab[meshName.name].children[1].material.metalness = 0;
                        scene.add(tab[meshName.name]);

                    })

                   
                       tab.GHaut.rotation.y = Math.PI*0.60
                
                     
                         tab.GBas.position.set(-11,-4,0)
                         tab.GBas.scale.z = 1.5;
                         tab.GBas.rotation.y = Math.PI*0.55
                     
              
                 });
                 //
                 
                 //
                 loader.load( 'blanc.glb', function ( gltf ) {
                    GMillieu = gltf.scene
                    GMillieu.scale.z = 1.2;

                    GMillieu.position.set(-11,0,0)
                    GMillieu.rotation.y = Math.PI*0.55
                    scene.add(GMillieu)
                    GMillieu.castShadow = true
                    GMillieu.receiveShadow = true
                    GMillieu.children[1].material.metalness = 0;

                     
                 });
                 //
                 loader.load( 'blanc.glb', function ( gltf ) {
                    DHaut = gltf.scene
                    DHaut.position.set(11,4,0)
                    DHaut.rotation.y = Math.PI*1.5
                    scene.add(DHaut)
                    DHaut.castShadow = true
                    DHaut.receiveShadow = true
                    DHaut.children[1].material.metalness = 0;
                     
                 });
                 
                 //
                 loader.load( 'blanc.glb', function ( gltf ) {
                    DMillieu = gltf.scene;
                 
                    DMillieu.scale.z = 1.2;

                    DMillieu.position.set(11,0,0)
                    DMillieu.rotation.y = Math.PI*1.5
                    scene.add(DMillieu)
                    DMillieu.castShadow = true
                    DMillieu.receiveShadow = true
                    DMillieu.children[1].material.metalness = 0;
              
                     
                 });
                 //
                 loader.load( 'blanc.glb', function ( gltf ) {
                    DBas = gltf.scene
                    DBas.scale.z = 1.5;

                    DBas.position.set(11,-4,0)
                    DBas.rotation.y = Math.PI*1.5
                    scene.add(DBas)
                    DBas.castShadow = true
                    DBas.receiveShadow = true
                    DBas.children[1].material.metalness = 0;
              
              
                     
                 });

                 loader.load( 'parchemin.glb', function ( gltf ) {
                    var originalParchemin = gltf.scene;
                    
                    var textloader = new THREE.FontLoader();
                    var material = new THREE.MeshBasicMaterial({color: 0xffffff});


                    meshParchemins.forEach((meshParchemins) =>{
                        
                        
                        tabParchemins[meshParchemins.name] = originalParchemin.clone();
                        tabParchemins[meshParchemins.name].position.set(meshParchemins.x,meshParchemins.y,meshParchemins.z)
                        tabParchemins[meshParchemins.name].scale.set(0.2,0.2,0.2)
                        tabParchemins[meshParchemins.name].castShadow = true
                        tabParchemins[meshParchemins.name].receiveShadow = true
                        tabParchemins[meshParchemins.name].children[1].material.metalness = 0;
                        scene.add(tabParchemins[meshParchemins.name]);

                        textloader.load('fontMc.json', function(font) {
        
                            tabParchemins[meshParchemins.nt]= new THREE.TextGeometry(meshParchemins.t, {
                            font: font,
                            size: 0.5,
                            height: 0.01,       
                        })
        
        
                        
                        tabParchemins[meshParchemins.nt] = new THREE.Mesh(tabParchemins[meshParchemins.nt], material);
                        scene.add( tabParchemins[meshParchemins.nt] );
                        tabParchemins[meshParchemins.nt].position.set(meshParchemins.x+2,meshParchemins.y,meshParchemins.z);
    
        
                        });

                    })
              

                     
                 });

                 
                 
            }


            // fonction qui permet d'initialiser les bodyPhysique / cannon

            function initBody() {

                // rotation pour la partie gauche
                var Gaxis = new CANNON.Vec3(0,1,0);
                // rotation pour la partie droite
                var Daxis = new CANNON.Vec3(0,-1,0);

                var angle = Math.PI / 2;
                                    
                // groundBody = new CANNON.Body({
                //     //shape: new CANNON.Plane(),
                //     shape: new CANNON.Box(new CANNON.Vec3(15,15,0.1)),
                //     type: CANNON.Body.STATIC
                // });
                // // permet de positionner le plane droit 
                // groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0)
                // world.addBody(groundBody);

                
              

                mainMeteorBody = new CANNON.Body({
                    shape: new CANNON.Sphere(0.37),
                    mass: 1
                });
                mainMeteorBody.position.set(getRandomArbitrary(10,20),getRandomArbitrary(10,20),0)
                world.addBody(mainMeteorBody);


                deuxexplodedMeteorBody = new CANNON.Body({
                    shape: new CANNON.Sphere(0.15),
                    mass: 1
                });
                world.addBody(deuxexplodedMeteorBody);
                deuxexplodedMeteorBody.position.set(10,00,00)
                troisexplodedMeteorBody = new CANNON.Body({
                    shape: new CANNON.Sphere(0.15),
                    mass: 1
                });
                world.addBody(troisexplodedMeteorBody);
                troisexplodedMeteorBody.position.set(20,00,00)

                quatreexplodedMeteorBody = new CANNON.Body({
                    shape: new CANNON.Sphere(0.15),
                    mass: 1
                });
                world.addBody(quatreexplodedMeteorBody);
                quatreexplodedMeteorBody.position.set(30,00,00)

                cinqexplodedMeteorBody = new CANNON.Body({
                    shape: new CANNON.Sphere(0.15),
                    mass: 1
                });
                world.addBody(cinqexplodedMeteorBody);
                cinqexplodedMeteorBody.position.set(40,00,00)

               



                    
                GHBody = new CANNON.Body({ mass: 0 });
                    // partie incliné
                    var shapeA = new CANNON.Box(new CANNON.Vec3(0.9,0.2,1));

                    GHBody.addShape(shapeA, new CANNON.Vec3(-0.6,0.3,2.8), new CANNON.Quaternion(0.32,0,0));

                    var shapeB = new CANNON.Box(new CANNON.Vec3(0.9,1.3,1.4));

                    GHBody.addShape(shapeB, new CANNON.Vec3(-0.6,-0.1,0.7), new CANNON.Quaternion());

                    var shapeC = new CANNON.Box(new CANNON.Vec3(0.9,0.6,1.5));
                    GHBody.addShape(shapeC, new CANNON.Vec3(-0.6,-0.8,2.55), new CANNON.Quaternion());

                    
                    GHBody.quaternion.setFromAxisAngle(Gaxis, angle);
                    GHBody.position.set(-11,4,0)
                    GHBody.quaternion.y = 0.7571067811865475;

                    world.addBody(GHBody);



                    DHBody = new CANNON.Body({ mass: 0 });
                    // partie incliné
                    var shapeA = new CANNON.Box(new CANNON.Vec3(0.9,0.2,1));

                    DHBody.addShape(shapeA, new CANNON.Vec3(-0.6,0.3,2.8), new CANNON.Quaternion(0.32,0,0));

                    var shapeB = new CANNON.Box(new CANNON.Vec3(0.9,1.3,1.4));

                    DHBody.addShape(shapeB, new CANNON.Vec3(-0.6,-0.1,0.7), new CANNON.Quaternion());

                    var shapeC = new CANNON.Box(new CANNON.Vec3(0.9,0.6,1.5));
                    DHBody.addShape(shapeC, new CANNON.Vec3(-0.6,-0.8,2.55), new CANNON.Quaternion());

                    DHBody.quaternion.setFromAxisAngle(Daxis, angle);
                    DHBody.position.set(11,4,0)
                    DHBody.quaternion.y =-0.7471067811865475

                    DHBody.type = CANNON.Body.STATIC
                    world.addBody(DHBody);

///////////
                    GMBody = new CANNON.Body({ mass: 0 });
                    // partie incliné
                    var shapeA = new CANNON.Box(new CANNON.Vec3(0.9,0.2,1.2));

                    GMBody.addShape(shapeA, new CANNON.Vec3(-0.6,0.4,3.5), new CANNON.Quaternion(0.32,0,0));

                    var shapeB = new CANNON.Box(new CANNON.Vec3(0.9,1.3,1.4));

                    GMBody.addShape(shapeB, new CANNON.Vec3(-0.6,-0.1,0.7), new CANNON.Quaternion());

                    var shapeC = new CANNON.Box(new CANNON.Vec3(0.9,0.6,2.3));
                    GMBody.addShape(shapeC, new CANNON.Vec3(-0.6,-0.8,2.55), new CANNON.Quaternion());

                    GMBody.quaternion.setFromAxisAngle(Gaxis, angle);
                    GMBody.quaternion.y = 0.7571067811865475;
                    GMBody.position.set(-11,0,0)
                    world.addBody(GMBody);

/////////////
                    DMBody = new CANNON.Body({ mass: 0 });
                    // partie incliné
                    var shapeA = new CANNON.Box(new CANNON.Vec3(0.9,0.2,1));

                    DMBody.addShape(shapeA, new CANNON.Vec3(-0.6,0.4,3.5), new CANNON.Quaternion(0.32,0,0));

                    var shapeB = new CANNON.Box(new CANNON.Vec3(0.9,1.3,1.4));

                    DMBody.addShape(shapeB, new CANNON.Vec3(-0.6,-0.1,0.7), new CANNON.Quaternion());

                    var shapeC = new CANNON.Box(new CANNON.Vec3(0.9,0.6,2.3));
                    DMBody.addShape(shapeC, new CANNON.Vec3(-0.6,-0.8,2.55), new CANNON.Quaternion());

                    DMBody.quaternion.setFromAxisAngle(Daxis, angle);
                    DMBody.quaternion.y =-0.7471067811865475
                    DMBody.position.set(11,0,0)
                    world.addBody(DMBody);


                    GBBody = new CANNON.Body({ mass: 0 });
                    // partie incliné
                    var shapeA = new CANNON.Box(new CANNON.Vec3(0.9,0.2,2));

                    GBBody.addShape(shapeA, new CANNON.Vec3(-0.3,0.4,4), new CANNON.Quaternion(0.19,0,0));

                    var shapeB = new CANNON.Box(new CANNON.Vec3(0.9,1.3,1.4));

                    GBBody.addShape(shapeB, new CANNON.Vec3(-0.6,-0.1,0.7), new CANNON.Quaternion());

                    var shapeC = new CANNON.Box(new CANNON.Vec3(0.9,0.6,3.5));
                    GBBody.addShape(shapeC, new CANNON.Vec3(-0.6,-0.8,2.70), new CANNON.Quaternion());

                    GBBody.quaternion.setFromAxisAngle(Gaxis, angle);

                    GBBody.position.set(-11,-4,0)
                    GBBody.quaternion.y = 0.7571067811865475;

                    world.addBody(GBBody);



                    DBBody = new CANNON.Body({ mass: 0 });
                    // partie incliné
                    var shapeA = new CANNON.Box(new CANNON.Vec3(0.9,0.2,1.7));

                    DBBody.addShape(shapeA, new CANNON.Vec3(-0.6,0.4,4.3), new CANNON.Quaternion(0.25,0,0));

                    var shapeB = new CANNON.Box(new CANNON.Vec3(0.9,1.3,1.4));

                    DBBody.addShape(shapeB, new CANNON.Vec3(-0.6,-0.1,0.7), new CANNON.Quaternion());

                    var shapeC = new CANNON.Box(new CANNON.Vec3(0.9,0.6,3.5));
                    DBBody.addShape(shapeC, new CANNON.Vec3(-0.6,-0.8,2.55), new CANNON.Quaternion());

                    DBBody.quaternion.setFromAxisAngle(Daxis, angle);

                    DBBody.position.set(11,-4,0)
                    DBBody.quaternion.y =-0.7471067811865475

                    world.addBody(DBBody);




                    portfolioBody = new CANNON.Body({ mass: 0 });
                    // partie incliné
                    var shapeA = new CANNON.Box(new CANNON.Vec3(3.2,0.5,0.1));

                    portfolioBody.addShape(shapeA, new CANNON.Vec3(0,0,0), new CANNON.Quaternion(0,0,0));


                    portfolioBody.position.set(0,7,0);

        

                    world.addBody(portfolioBody);


            }

            profilSection();
            function profilSection() {
                // la barre 
                var textloader = new THREE.FontLoader();

                    textloader.load('fontMc.json', function(font) {
                        var material = new THREE.MeshBasicMaterial({
                        color: 0xffffff
                    });

                    var textProfil = new THREE.TextGeometry(`Dylan est l'un des maitre les plus difficile a battre\n dans le monde du developpement.\n\n Les entreprises peuvent le retrouver a la fin du jeu,\n et redoutent sa proactivité et son professionnalisme.\n\n Comme beaucoup de maitres, Dylan est rapide et peut\n rapidement vaincre les joueurs avec son ensemble\n de fonctions javascript unique. `, {
                    font: font,
                    size: 0.5,
                    height: 0.01,  
                })

                
                textProfil = new THREE.Mesh(textProfil, material);
                scene.add( textProfil );
                textProfil.position.y = -17
                textProfil.position.x = -3
                textProfil.position.z = 0.5




                const geoBarre = new THREE.BoxGeometry( 0.5, 10, 0.5 );
                const materiall = new THREE.MeshBasicMaterial( {color: 0xffffff} );

                const barre = new THREE.Mesh( geoBarre, materiall );
                scene.add( barre );
                barre.position.y = -20
                barre.position.x = -5

                
                    
                });


            }
            parcoursSection();
            documentationSection();

            function parcoursSection() {
                var textloader = new THREE.FontLoader();

                textloader.load('fontMc.json', function(font) {
                    var material = new THREE.MeshBasicMaterial({color: 0xffffff});

                    var textParcours = new THREE.TextGeometry(`Vous pouvez suivre l’incroyable histoire du maitre Dylan. `, {
                    font: font,
                    size: 0.4,
                    height: 0.01,       
                })


                textParcours = new THREE.Mesh(textParcours, material);
                scene.add( textParcours );
                textParcours.position.y = -41
                textParcours.position.x = -17
                textParcours.position.z = 0.5




                const geoBarre = new THREE.BoxGeometry( 0.5, 10, 0.5 );
                const materiall = new THREE.MeshBasicMaterial( {color: 0xffffff} );

                const barre = new THREE.Mesh( geoBarre, materiall );
                scene.add( barre );
                barre.position.y = -40
                barre.position.x = 5



                });
            }

            function documentationSection(){
               

            }
            // Return un nombre aléatoire @nombre minium @nombre maximum
            function getRandomArbitrary(min, max) {
                return Math.random() * (max - min) + min;
            }

		</script>
	</body>
</html>